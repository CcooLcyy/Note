# 基本概念

| 数据  | 数据元素  | 数据对象 | 数据类型 | 数据结构 |
| ----- | --------- | ------- | -------- | -------- |
| 信息的载体 | 数据的基本单位 | 相同性质的数据元素的集合 | 原子类型、结构类型、抽象数据类型 | 三要素：逻辑结构、存储结构、数据的运算 |

数据结构三要素：

1. 逻辑结构：从逻辑上描述数据，独立于计算机
2. 存储结构：物理结构。在计算机中的表示（映射），依靠计算机语言实现。有顺序、链式、索引、散列。
   1. 顺序：在逻辑位置上相邻，物理位置也相邻
   2. 链式：逻辑位置相邻，物理位置不一定相邻。
   3. 索引：建立索引表，索引表占用一定空间，但是检索速度快。同时，在修改数据的时候，也要修改索引表。
   4. 散列：根据散列函数计算出数据的存储位置。又称Hash存储。增删改查都很快，但依靠散列函数的好坏，否则解决冲突占用时间也很大
3. 数据的运算：由逻辑结构定义，由存储结构实现。

# 算法

## 算法特性

1. 有穷性：算法必须在有穷步之后得出结果
2. 确定性：每条指令必须要有确切的含义
3. 可行性：算法必须通过已经实现的基本步骤实现
4. 输入：有0或多个输入
5. 输出：有1或多个输出

## 算法评价

### 时间复杂度

该语句在算法中被重复执行的次数。
$$
T(n)=O(f(n))
$$
通常采用算法中基本运算的频度来分析算法的时间复杂度。O（大写字母O）表示T(n)的数量级。

算法的时间复杂度与问题的规模有关，同时取决于待输入数据的性质。
$$
T(n)=T_1(n)+T_2(n)=O(f_1(n))+O(f_2(n))=O(max(T_1(n),T_2(n)))
$$

#### 乘法法则

$$
T(n)=T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f*g)
$$

#### 常见算法复杂度比较

$$
O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
$$

### 空间复杂度

算法所消耗的存储空间，是问题规模的函数。除了基本的指令、常量、变量、输入数据之外，消耗的额外的空间称为辅助空间。

#### 算法原地工作

辅助空间为常量O(1)

# 线性表

## 定义

具有相同数据类型的有限序列。除**表头元素**外，每一个元素都有一个**直接前驱**。除**表尾元素**外，每一个元素都有一个**直接后继**。

线性表是逻辑结构，有两种物理结构存储（顺序存储、链式存储）

## 线性表的基本操作（逻辑上的操作）

init_list()

length()

locate_elem()

get_elem()

list_insert()

list_delete()

print_list()

is_empty()

destroy_list()

基本操作如何实现的可以不考虑，但是能够用编程语言实现。

## 顺序表

物理顺序与逻辑顺序相同，也就是逻辑上相邻物理上也相邻。顺序表存储密度高，可以实现随机存取，但是增删改操作时间复杂度为O(n)

### 动态分配与静态分配

静态分配的顺序表一旦占满就会产生溢出，导致程序错误。可以使用动态分配的顺序表，一旦占满就会请求新的空间，从而达到扩充空间的目的。

## 链表

由于顺序表的增删需要移动大量元素。

### 单链表

每个结构体中有一个指向后面一个结构的指针。

用一个指针来标识一个单链表，当头指针为NULL时表示该表为空表。在头指针后跟一个**头节点**其中没有任何数据，或者用来表示表长。头节点的引入可以将空表和非空表的处理统一。也就是说无论表空与否，头指针总是指向一个节点。

#### 插入

单链表的插入实现分为**头插法**和**尾插法**。头插法会生成一个与传入数据逆序的列表，尾插法需要一个尾指针，不断改变尾指针的位置。实现尾插法。

### 双链表

单链表可以解决增删移动大量元素的问题，但是只能后索引，无法向前索引。因此引入双链表，也就是在结构体中再添加一个指向前一个节点的指针，就可以实现向前索引。

双链表的增删需要注意指针的赋值顺序，很容易覆盖指针造成指针丢失。

### 循环链表（单、双）

就是再单链表和双链表的基础上将最后一个节点的指向头节点即可。

### 静态链表（游标）

在没有指针功能的编程语言中，可以使用**游标**来编写链表。游标本质上就是在一个数组中，使用链式的方法来描述。与顺序表一样，需要提前分配一篇地址空间。

## 栈（FILO）

是一种操作受限的线性表，也就是说我们无法，或者在逻辑实现上就不应该对栈内进行操作，只对栈顶进行操作。

### 顺序栈

与顺序表的实现很类似，但是操作的时候要注意只能对栈顶进行操作

### 共享栈

由两个栈共享同一个数组，分别从一个一维数组的两端向中间进行延伸。只有当栈同时将数组填满之后才会发生溢出，两个栈动态的共享这个数组。

### 栈的链式实现

与链表类似，同样也只能对栈顶进行操作。有点也和链表类似，可以提高内存的利用率

## 队列（FIFO）

是一种操作受限的线性表。有**入队**和**出队**两个操作。只允许在一端进行插入，在另一端进行删除。

### 队列的顺序存储

### 循环队列

### 链式存储

### 双端队列
